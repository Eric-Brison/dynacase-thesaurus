<?php


include_once("FDL[GEN]/Class.[DocParent].php");
[include]
Class ADoc[docid] extends [AParent] {
    // for familly : [title]

   function ADoc[docid] () {
      [AParent]::[AParent]();

     [BLOCK MATTR]
     $this->attr["[attrid]"]=new MenuAttribute("[attrid]", "[docid]","[label]",[order],"[link]","[precond]");
    
     [ENDBLOCK MATTR]
     [BLOCK FATTR]
     $this->attr["[attrid]"]=new FieldSetAttribute("[attrid]", "[docid]","[label]","[visibility]");

     [ENDBLOCK FATTR]
     [BLOCK NATTR]
     $this->attr["[attrid]"]=new NormalAttribute("[attrid]", "[docid]","[label]","[type]","[format]",[repeat],[order],"[link]",
                                                "[visibility]",[needed],[title],[abstract],
						$this->attr["[frame]"],"[phpfile]","[phpfunc]","[elink]");

     [ENDBLOCK NATTR]
     $this->fromids[[docid]]=[docid];
[BLOCK ATTRFIELD]
    $this->fields["[attrid]"]="[attrid]";[ENDBLOCK ATTRFIELD]
   }
}

Class Doc[docid] extends [DocParent] {
   //  family : [title]

   var $dbtable="doc[docid]";
   var $dbseq="seq_doc[docid]";
   var $sqlcreate = array("create table doc[docid] ([sattr]) inherits (doc[fromid]);",
     "create unique index doc_pkey[docid] on doc[docid](id);",
     "create sequence seq_doc[docid] start 1;",
     "select setval('seq_doc[docid]', count(distinct initid)+1, false )  from only doc[docid];");
   var $sqltcreate =
     "CREATE OR REPLACE FUNCTION upval[docid]() RETURNS trigger AS '
declare	
begin
[BLOCK ATTRFIELD2]
if not NEW.[attrid] isnull then
  NEW.values := NEW.values || ''£'' || NEW.[attrid];
  NEW.attrids := NEW.attrids || ''£'' || ''[attrid]'';
end if;[ENDBLOCK ATTRFIELD2]
  return NEW;
end;
' LANGUAGE 'plpgsql'; "; // sql trigger

     var $fromid=[docid];

   function Doc[docid] ($dbaccess='', $id='',$res='',$dbid=0) {
    $this->attributes = new ADoc[docid]();
    

    if (isset($this->attributes->fields))  $this->fields += $this->attributes->fields;
    [pinit]::[pinit]($dbaccess, intval($id), $res, $dbid);

    uasort($this->attributes->attr,"tordered"); 
       
   }

   function SpecRefreshGen() {
     $err = parent::SpecRefreshGen();
[BLOCK ACALC]
    // -------------------
  if (method_exists($this,"[method]")) {
    $arraycount=0;
    $iargs=array();
  [BLOCK [biattr]]
    $attr = $this->getAttribute("[niarg]");
    if (! $attr) $iargs[]="[niarg]";
    else {
      if ($attr->inArray()) {
	$t = $this->getTValue("[niarg]");
	$iargs[]=$t;
	$arraycount=count($t);
      } else $iargs[]=$this->getValue("[niarg]");
    }
  [ENDBLOCK [biattr]]

    $this->AddParamRefresh("[niargs]","[rarg]");
    if ($arraycount > 0) {
      $tv=array();
      for ($c=0;$c<$arraycount;$c++) {
	$tiargs=array(); // parameters for each row
	reset($iargs);
	while (list($k, $va) = each($iargs)) {
	  if (is_array($va)) $tiargs[]=$va[$c];
	  else $tiargs[]=$va;
	}
	$tv[] = call_user_method_array("[method]",$this,$tiargs);
	
      }
      $this->setValue("[rarg]",implode("\\n",$tv)); 
    } else {
      $v = call_user_method_array("[method]",$this,$iargs);
      $this->setValue("[rarg]",$v); 
    }
  }  else {
      $err.= sprintf(_("method %s does not exist."),"[method]");
    }[ENDBLOCK ACALC]

       return $err;
   }
   [METHODS]

}

     [BLOCK CLASSALIAS]
// alias name for the class
Class _[docName] extends Doc[docid] {
}
     [ENDBLOCK CLASSALIAS]
?>
